extern crate capnpc;

use std::env::set_var;
use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;
use std::path::PathBuf;

const SOURCE_PREFIX: &str = "#![cfg_attr(feature = \"cargo-clippy\", allow(clippy_lint))]\n\n";

fn fix(path: PathBuf) {
    let original_contents = {
        let mut file = File::open(&path).expect(&format!(
            "Expected to be able to open the autogenerated source at {:?}",
            &path
        ));

        let mut contents = String::new();

        file.read_to_string(&mut contents).expect(&format!(
            "Expected to be able to read the autogenerated source at {:?}",
            &path
        ));

        contents
    };

    let mut fixed_contents = String::new();
    fixed_contents.push_str(SOURCE_PREFIX);
    fixed_contents.push_str(&original_contents.replace("::indradb_capnp::", "::autogen::indradb_capnp::"));

    let mut file = File::create(&path).expect(&format!(
        "Expected to be able to open the autogenerated source at {:?}",
        &path
    ));

    file.write_all(fixed_contents.as_bytes()).expect(&format!(
        "Expected to be able to write to the autogenerated source at {:?}",
        &path
    ));
}

fn main() {
    set_var("OUT_DIR", "src/common/autogen");

    capnpc::CompilerCommand::new()
        .file("indradb.capnp")
        .run()
        .expect("Expected to be able to compile capnp schemas");

    // This hackiness is because capnproto assumes the modules are at the
    // crate root, and we need to fix that
    let path = Path::new(".")
        .join("src")
        .join("common")
        .join("autogen")
        .join("indradb_capnp.rs");
    fix(path);
}
